[bitacora 27/06/2025 11:30pm] 

He montado lo que vendria siendo todo lo que es la base del proyecto, cree la aplicacion de NetBeans "Gestor_pacientes" con dos paquetes: gestor_pacientes y Estructuras.

En gestor_pacientes estara la clase main con todos sus metodos estaticos para que solo funcionen alli

Y en Estructuras estaran las estructuras de datos ordenadas para que haya orden, las que meti por ahora fueron ALVTree, BinarySearchTree y solo me estaria faltando la de Cola.

Teniendo ya todo ordenado y estructurado he programado el primer metodo de la parte estetica y que definira el flujo del programa, el metodo menu(); que sera la interfaz principal que te dejara elegir entre las 3 opciones expuestas en el PDF del proyecto.

 System.out.println("1. Gestionar Registro Histórico de Expedientes.");
 System.out.println("2. Gestionar Cola de Atención Activa.");
 System.out.println("3. Salir del sistema.");

La idea es que el usuario dependiendo de lo que elija la opcion entre en un Switch y dependiendo de lo que elija corra el metodo correspondiente, si elije el 1 que corra el metodo para gestionar los historicos; Asi mismo con la opcion 2. 

[bitacora 28/06/2025 9:30pm] 

El dia de hoy lo que se hizo fue, analizar un poco el desarrollo, nos dimos cuenta que la clase cola no es necesaria, con el arbol AVL basta para la parte 2. Teniendo esto en cuenta creamos la clase Paciente con los atributos necesarios.

    private int id; //datos personales    
    private String nombre;    
    private String sexo;
    private int edad;    
    private String fechaNacimiento; 
    
    //registros
    private String diagnostico;
    private String motivo;
    private String prioridad;

Con esa clase ya definida, empezamos a arreglar el arbol binario de busqueda, contenida en la clase BinarySearchTree.java, modificando su nodo, que ya no se cree a partir de numeros enteros si no que almacene una clase Paciente, teniendo eso ya arreglado nos lanzamos ahora si a BinarySearchTree.java donde comentamos los metodos que todavia no vamos a usar y solo nos quedamos con insert y search. Los cuales adaptamos para que funcione con clases Paciente y se se hara una comparacion o busqueda que sea en base al atributo id del Paciente (que es en base a esos ids que esta ordenado todo en el arbol)

En la clase main hicimos el segundo menu, el menu de expedientes, donde se tratara completamente este arbol. 

Hemos definido antes como globales 1 variable y un objeto del arbol que antes importamos.

import Estructuras.Paciente;
import Estructuras.BinarySearchTree;

static BinarySearchTree historial = new BinarySearchTree();
static int expedienteId = 0;

Teniendo eso listo, empezamos con la siguiente interfaz

private static void menuExpedientes() {
    Scanner scanner = new Scanner (System.in);
        int opcion = 0;
        do {         
        System.out.println("Usted ha seleccionado: Gestionar registro histórico de expedientes.");
        System.out.println("1. Registrar un nuevo expediente.");
        System.out.println("2. Buscar un registro.");
        System.out.println("3. Listar todos los registros.");
        System.out.println("4. Regresar al menu principal.");
        System.out.print("Seleccione una opcion: ");
        
        opcion =  Integer.parseInt(scanner.nextLine()); 
          switch (opcion) {
              case 1:
                  registrarPaciente();
                  break;

En donde nuestro registrarPaciente(); tendra el formulario donde:

1. Se creara la clase Paciente con los datos correspondientes y MUY IMPORTANTE estara el expedienteId++; que hara que por cada paciente registrado su id de atributo aumente 1+ haciendo asi que con cada ejecucion de este metodo el garantice que el siguiente paciente sea un numero mayor. Una vez la clase haya sido creada correctamente.

        // con estos datos recopilados, montamos la clase
        Paciente paciente = new Paciente (expedienteId, nombre, sexo, edad, fechaNacimiento, motivo, diagnostico, prioridad);
        System.out.println(paciente.toString()); 

2. En base a ese paciente registrado, llamamos al arbol llamado historial con su metodo insert

        // y en base a ese paciente registrado, lo guardamos en el arbol
        historial.insert(paciente);

Registrando asi a los pacientes en el arbol por su id, que incrementa con cada ejecucion.

Luego pasamos con: 

        case 2:
        	buscarRegistro();
        break;

donde el metodo buscar registro, tendra una funcionalidad parecida a la de insertar, preguntara al usuario el id del usuario que quiere buscar, si esta registrado muestra sus datos, si no (la busqueda devolvio null), le dice que no hay usuario con ese id y lo devuelve al menu. Haciendo uso de una clase temporal llamada paciente temporal que solo usaremos para comparar con algun paciente del arbol ya que no podemos comparar un numero entero si el arbol solo recibe clases Pacientes.

        System.out.print("Ingrese el id del registro del paciente: ");
        int idAsignado = Integer.parseInt(scanner.nextLine());

        Paciente pacienteTemporal = new Paciente(idAsignado, "", "", 0, "", "", "", "");
        Paciente Encontrado = historial.search(pacienteTemporal);

        // no le podemos meter un id, porque espera una clase paciente.
        historial.search(Encontrado);
        if (Encontrado != null){
            System.out.println("Paciente encontrado.");
            System.out.println(Encontrado);
        }

Para el search hemos usado IA para identificar que comparar con que, en este caso seria el id que le damos como parametro con el paciente que tambien le damos como parametro, si hay coincidencia, nos devuelve el paciente con todos sus datos. Justificada esta el uso porque casi que el 90% de este commit fue hecho hasta que nos bloqueamos en esa parte.

Pasamos de 

    private boolean recursiveSearch(Node current, int key) {
        // Caso base: Si el árbol está vacío o la clave se encuentra en la raíz
        if (current == null || current.key == key) {
            return current != null; // True si se encontró, false si current es null
        }

        // Si la clave es menor que la clave de la raíz, buscar en el subárbol izquierdo
        if (key < current.key) {
            return recursiveSearch(current.left, key);
        }
        // Si la clave es mayor que la clave de la raíz, buscar en el subárbol derecho
        else {
            return recursiveSearch(current.right, key);
        }
    }

a

    private Paciente recursiveSearch(Node current, int id) {
        // Caso base: Si el árbol está vacío o la clave se encuentra en la raíz
        if (current == null) {
            return null; // no se encontro
        } 
        
        if (current.paciente.getId() == id) { // se encontro
            return current.paciente;
        }
       
        // Si la clave es menor que la clave de la raíz, buscar en el subárbol izquierdo
        if (id < current.paciente.getId()) {
            return recursiveSearch(current.left, id);
        }
        // Si la clave es mayor que la clave de la raíz, buscar en el subárbol derecho
        else {
            return recursiveSearch(current.right, id);
        }
    }

Y en cuanto a lo demas, preguntas muy generales en cuanto al uso de correcto de algunas metodlogias en NetBeans y el propio java

[bitacora 29/06/2025 4:30pm] 

Ok, en cuanto a la parte de Gestionar Registro Histórico de Expedientes solo falta el listar todos los registros de pacientes

· Listar todos los registros.

Para ello hemos adaptado el metodo inorder dado por el profesor para que funcione con nuestra clase pacientes, el current.key, lo cambiamos a current.pacientes y para que visualmente sea mas agradable en consola a la vista del usuario corregimos los println. Teniendo esto arreglado y adaptado, en el case 4 del switch de menuRegistros simplemente agregamos un historial.inorder(); y en la consola se muestra algo como

[id 1, datosdelusuario]
[id 2, datosdelusuario]
[id 3, datosdelusuario]

Mostrando de forma correcta y enlistados.

En este punto, ya podemos pasar a la parte 2: Gestionar Cola de Atención Activa.

Lo primero sera empezar a modificar el arbol AVL para que funcione con Pacientes, pero antes de ello, empezamos a hacer la interfaz en main.java, asi como funcionaba perfecto menuRegistros(); hicimos un menuCola(); que basicamente es un copy-paste del de registros, solo que en los switch los nuevos metodos que manejaran los datos y el arbol AVL.

Volviendo al arbol, la primera parte de la adaptacion para los pacientes es cambiar su nodo que funcionaba con key a que funcione con Pacientes

    static class NodeAVLTree {
        Paciente paciente;
        int height; // Altura del nodo (distancia desde este nodo a la hoja más lejana)
        NodeAVLTree left, right;

        public NodeAVLTree(Paciente paciente) {
            this.paciente = paciente;
            height = 1; // Un nuevo nodo es una hoja, por lo que su altura inicial es 1
            left = right = null;
        }
    }

Y en el metodo insert se hace basicamente lo que se hizo en el arbol binario de busqueda, las key las cambiamos por persona y en comparaciones las cambiamos por persona.getId() o current.persona.getId(); dependiendo, fuimos tanteando purbea y error prueba y error hasta que funcionara correctamente, nuestro metodo quedo algo asi

public void insert(Paciente paciente) {
        root = recursiveInsert(root, paciente);
    }

    // Método recursivo para insertar un nodo y rebalancear el árbol AVL.
    private NodeAVLTree recursiveInsert(NodeAVLTree current, Paciente paciente) {
        // 1. Realiza la inserción normal de BST
        if (current == null) {
            return new NodeAVLTree(paciente);
        }

        if (paciente.getId() < current.paciente.getId()) {
            current.left = recursiveInsert(current.left, paciente);
        } else if (paciente.getId()> current.paciente.getId()) {
            current.right = recursiveInsert(current.right, paciente);
        } else { // Claves duplicadas no permitidas en este ejemplo
            return current;
        }

        // 2. Actualiza la altura del nodo actual
        current.height = 1 + max(height(current.left), height(current.right));

        // 3. Obtiene el factor de equilibrio de este nodo para verificar si se desbalanceó
        int balance = getBalance(current);

        // 4. Si el nodo se desbalanceó, hay 4 casos:

        // Caso Izquierda-Izquierda (LL)
        if (balance > 1 && paciente.getId() < current.left.paciente.getId()) {
            return rightRotate(current);
        }

        // Caso Derecha-Derecha (RR)
        if (balance < -1 && paciente.getId() > current.right.paciente.getId()) {
            return leftRotate(current);
        }

        // Caso Izquierda-Derecha (LR)
        if (balance > 1 && paciente.getId() > current.left.paciente.getId()) {
            current.left = leftRotate(current.left);
            return rightRotate(current);
        }

        // Caso Derecha-Izquierda (RL)
        if (balance < -1 && paciente.getId() < current.right.paciente.getId()) {
            current.right = rightRotate(current.right);
            return leftRotate(current);
        }

        // Retorna el nodo (sin cambios si está balanceado)
        return current;
    }

Teniendo esto, hicimos nuestro metodo agregarPacienteCola() que lo bueno de hacer todo el programa de forma modular, es que ahora simplemente copiamos y pegamos nuestro metodo anterior agregarRegistro(); y lo adaptamos para que funcione con cola.insert(Encontrado);

Bien, en este punto la cola solo añadira a alguien a la cola si ya existe en el historial.

    
    private static void agregarPacienteCola() {
    Scanner scanner = new Scanner (System.in);   
        System.out.print("Ingrese el id del paciente que quiere agregar a la cola: ");
        int idAsignado = Integer.parseInt(scanner.nextLine());

        Paciente pacienteTemporal = new Paciente(idAsignado, "", "", 0, "", "", "", "");
        Paciente Encontrado = historial.search(pacienteTemporal);


        if (Encontrado != null){        
            cola.insert(Encontrado);
            System.out.println("Paciente agregado a la cola.");
            System.out.println(Encontrado);
        }
        else {
            System.out.println("Paciente no encontrado en el historial.");
        }
    }

Perfecto, con esto implementado ya funciona perfecto la insercion, pero no hay forma de verlo. Tendremos que adaptar el inorder para que funcione con pacientes y que nos enliste los pacientes en cola. Hacemos lo mismo que hicismos en el arbol binario. adapatamos el indorder para que funcione con pacientes 

    public void inorder() {
        System.out.println("Rgistros en el sistema:");
        recursiveInorder(root);
        System.out.println();
    }

    private void recursiveInorder(Node current) {
        if (current != null) {
            recursiveInorder(current.left);
            System.out.println(current.paciente + " ");
            recursiveInorder(current.right);
        }
    }
}

Para este punto ya tenemos 3. Ver cola actual. que no nos lo piden en el enunciado pero es clave como adicion.

Ok, entonces ahora trabajaremos con 

· Buscar un paciente en espera (mediante su id).

creamos un metodo llamado search en el AVL, en esencia funcionara igual que el search del arbol binario de busqueda, aprovechando que AVL tambien mantiene la propieda de orden binario 

public Paciente search(Paciente paciente) Queda igual pero con los cambios adaptados a pacientes

y el private Paciente recursiveSearch(NodeAVLTree current, int id) para que funcione con el nodo del arbol AVL y el id 

en esencia lo mismo que en el binario

private Paciente recursiveSearch(NodeAVLTree current, int id) {
        // Caso base: Si el árbol está vacío o la clave se encuentra en la raíz
        if (current == null) {
            return null; // no se encontro
        } 
        
        if (current.paciente.getId() == id) { // se encontro
            return current.paciente;
        }
       
        // Si la clave es menor que la clave de la raíz, buscar en el subárbol izquierdo
        if (id < current.paciente.getId()) {
            return recursiveSearch(current.left, id);
        }
        // Si la clave es mayor que la clave de la raíz, buscar en el subárbol derecho
        else {
            return recursiveSearch(current.right, id);
        }
    }

Y lo demas igual, va recorriendo izquierda y derecha hasta encontrar el paciente.

y nuestro metodo en la main queda asi 

    private static void buscarPacienteCola() {
        Scanner scanner = new Scanner (System.in);   
        System.out.print("Ingrese el id del registro del paciente: ");
        int idAsignado = Integer.parseInt(scanner.nextLine());

        Paciente pacienteTemporal = new Paciente(idAsignado, "", "", 0, "", "", "", "");
        Paciente Encontrado = cola.search(pacienteTemporal);
        
        if (Encontrado != null){        
            cola.search(Encontrado);
            System.out.println("Paciente en la cola encontrado.");
            System.out.println(Encontrado);
        }
        else {
            System.out.println("paciente inexistente en la cola.");
        }
    }

que si lo comparamos con 

        private static void buscarRegistro() {
        Scanner scanner = new Scanner (System.in);   
        System.out.print("Ingrese el id del registro del paciente: ");
        int idAsignado = Integer.parseInt(scanner.nextLine());

        Paciente pacienteTemporal = new Paciente(idAsignado, "", "", 0, "", "", "", "");
        Paciente Encontrado = historial.search(pacienteTemporal);

        // no le podemos meter un id, porque espera una clase paciente.

        if (Encontrado != null){        
            historial.search(Encontrado);
            System.out.println("Paciente encontrado.");
            System.out.println(Encontrado);
        }
        else {
            System.out.println("paciente no encontrado.");
        }
    }

es practicamente lo mismo, pero este buscara el usuario si existe en cola (arbol AVL) este lo mostrara con todos sus atributos.

y bien, como ultima adicion seria el modulo de 

· Eliminar un paciente de la cola (mediante su id, por ser atendido, etc.).

En el menuCola se encuentra de 4to lugar y es 

System.out.println("4. Eliminar paciente de la cola.");

                case 4:
                    eliminarPacienteCola(); 
                    break;

Funcionara como los otros 2 metodos:

    private static void eliminarPacienteCola() {
        Scanner scanner = new Scanner (System.in);   
        System.out.print("Ingrese el id del registro del paciente: ");
        int idAsignado = Integer.parseInt(scanner.nextLine());

        Paciente pacienteTemporal = new Paciente(idAsignado, "", "", 0, "", "", "", "");
        Paciente Encontrado = cola.search(pacienteTemporal);
        
        if (Encontrado != null){        
            cola.delete(Encontrado);
            System.out.println("Paciente en la cola eliminado.");
        }
        else {
            System.out.println("paciente inexistente en la cola.");
        }
    }

Se le pasara un id

> lo buscara en la cola: Paciente Encontrado = cola.search(pacienteTemporal);
> al encontrarlo: cola.delete(Encontrado);

Entonces del arbol binario de busqueda buscamos el metodo delete.

Y lo adaptamos para que funcione con pacientes. Pero aqui no lo podemos hacer asi como asi, al eliminarse, debe balancearse el arbol AVL. nuestro metodo quedo asi

[Esta parte igual del arbol binario]

ublic void delete(Paciente paciente) {
        root = recursiveDelete(root, paciente.getId());
    }

    private NodeAVLTree recursiveDelete(NodeAVLTree current, int id) {
        if (current == null) {
            return null;
        }

        // Buscar el nodo a eliminar
        if (id < current.paciente.getId()) {
            current.left = recursiveDelete(current.left, id);
        } else if (id > current.paciente.getId()) {
            current.right = recursiveDelete(current.right, id);
        } else {
            // Nodo encontrado

            // Caso 1: Un solo hijo o ninguno
            if (current.left == null) {
                return current.right;
            } else if (current.right == null) {
                return current.left;
            }

Pero aqui cambia 

// Caso 2: Dos hijos
            NodeAVLTree sucesor = minValue(current.right);
            current.paciente = sucesor.paciente; // Reemplazar con el paciente sucesor
            current.right = recursiveDelete(current.right, sucesor.paciente.getId());
        }

        // Actualizar altura
        current.height = 1 + max(height(current.left), height(current.right));

        // Rebalancear
        int balance = getBalance(current);

        // Casos de desbalanceo
        if (balance > 1 && getBalance(current.left) >= 0)
            return rightRotate(current);
        if (balance > 1 && getBalance(current.left) < 0) {
            current.left = leftRotate(current.left);
            return rightRotate(current);
        }
        if (balance < -1 && getBalance(current.right) <= 0)
            return leftRotate(current);
        if (balance < -1 && getBalance(current.right) > 0) {
            current.right = rightRotate(current.right);
            return leftRotate(current);
        }

        return current;

Basicamente es el metodo que lo balanceara buscando que todo quede en 1 y 0 y no hayan mas balances criticos en la izquierda y derecha. haciendo int balance = getBalance(current); cada vez hasta que quede balanceado

el metodo que avalua el balance es 

    private int getBalance(NodeAVLTree N) {
        if (N == null) {
            return 0;
        }
        return height(N.left) - height(N.right);
    }

Y ya lo trae la clase AVL que nos proporciono el profesor.
            

Commit 3 - Gestionador de expedientes y Cola de atencion activa lista

El gestionador de historico de expedientes esta 100% funcional, se termino su ultimo modulo que le faltaba, se adapato el inorder para que funcione con pacientes.

· Listar todos los registros. 

Se ha adaptado el arbol AVL para que funcione con pacientes tambien, 

· Registrar/Actualizar un paciente en espera (mediante su id).
· Buscar un paciente en espera (mediante su id).
· Eliminar un paciente de la cola (mediante su id, por ser atendido, etc.).

Gracias a la adaptacion funcionan esos 3 requisitos.


[bitacora 29/06/2025 8:30pm] 

Para este punto, el programa esta 100% funcional, pero nos falta validaciones, en los menus, cuando nos piden numeros de 1 al 4 y el usuario mete una letra, se cierra la ejecucion, Al igual cuando que cuando nos piden el id en en muchos metodos de busqueda o para eliminar, si metemos una letra se rompe, para solucionarlo de forma modular hemos puesto este codigo en

los menus:

        try {
            opcion = Integer.parseInt(scanner.nextLine());
        } catch (NumberFormatException e) {
            System.out.print("Elija un valor válido.");
            opcion = -1; 
        }

y en los case default 

              default:
                  System.out.println("(Entrada numerica del 1 al 3)\n");
                  break;
                  }
        } while (opcion != 3);

Permitiendo asi que la ejecucion del menu se repita hasta que haya una entrada valida, estos aparecen En menu(), menuRegistro() y menuCola();

para la busqueda o eliminacion de pacientes en los arboles, siempre piden el id

lo que hicimos fue colocar 

        int idAsignado = -1;
        while (idAsignado < 0) {
            try {
                System.out.print("Ingrese el id del registro del paciente: ");
                idAsignado = Integer.parseInt(scanner.nextLine());
                if (idAsignado < 0) {
                    System.out.println("ID inválido. Debe ser un número positivo.");
                }
            } catch (NumberFormatException e) {
                System.out.println("Debe ingresar un número entero válido.");
            }
        }

Aparece en BuscarRegistro(), agregarPacienteCola(), buscarPacienteCola(), eliminarPacienteCola();

Por ultimo, el formulario para ingresar un nuevo paciente al historial

   private static void registrarPaciente() {
        Scanner scanner = new Scanner (System.in);
        expedienteId++;
        System.out.println("[Formulario] registrar nuevo paciente.");
        //aqui vamos a registrar todos los datos del paciente, nombre, sexo, edad, fecha de nacimiento, motivo, diagnostico, prioridad (el id se autoasigna)
        String nombre;
        do {
            System.out.print("Ingrese el nombre completo del paciente: ");
            nombre = scanner.nextLine().trim();
        } while (nombre.isEmpty());

        String sexo;
        do {
            System.out.print("Ingrese el sexo del paciente (H/M): ");
            sexo = scanner.nextLine().trim().toUpperCase();
        } while (!sexo.equals("H") && !sexo.equals("M"));

        int edad = -1;
        while (edad < 0) {
            try {
                System.out.print("Ingrese la edad del paciente: ");
                edad = Integer.parseInt(scanner.nextLine());
                if (edad < 0) System.out.println("Edad inválida.");
            } catch (NumberFormatException e) {
                System.out.println("Debe ingresar un número entero válido.");
            }
        }

        String fechaNacimiento;
        do {
            System.out.print("Ingrese la fecha de nacimiento: ");
            fechaNacimiento = scanner.nextLine().trim();
        } while (fechaNacimiento.isEmpty());

        String motivo;
        do {
            System.out.print("Ingrese el motivo de la consulta: ");
            motivo = scanner.nextLine().trim();
        } while (motivo.isEmpty());

        String diagnostico;
        do {
            System.out.print("Ingrese el diagnóstico: ");
            diagnostico = scanner.nextLine().trim();
        } while (diagnostico.isEmpty());

        String prioridad;
        do {
            System.out.print("Ingrese la prioridad (baja, media o alta): ");
            prioridad = scanner.nextLine().trim().toLowerCase();
        } while (!prioridad.equals("baja") && !prioridad.equals("media") && !prioridad.equals("alta"));

        // con estos datos recopilados, montamos la clase
        Paciente paciente = new Paciente (expedienteId, nombre, sexo, edad, fechaNacimiento, motivo, diagnostico, prioridad);
        System.out.println(paciente.toString()); 
        // y en base a ese paciente registrado, lo guardamos en el arbol
        historial.insert(paciente);
        System.out.println("Paciente registrado correctamente:");
        }

Guardamos las entradas luego de que las condiciones se cumplan, en todos no se puede dejar vacio el campo, en los numericos como la edad no se puede añadir letras o numeros negativos y para valores unicos como H o M, o prioridad baja media o alta, no te dejara continuar hasta meter bien los valores. En cuanto a las entradas a los arboles, si no metes una letra no te deja avanzar hasta que metas un numero enetero y si el numero no coincide con alguno del arbol, el arbol internamente tiene que si el valor es nulo, te manda una excepcion.

Y por ultimo el system.exit() en menu.